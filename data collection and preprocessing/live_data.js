// const fs = require("fs");
// const RSSParser = require("rss-parser");
// const schedule = require("node-schedule");

// const parser = new RSSParser();

// function loadWebsitesFromJSON() {
//     try {
//         // Read the JSON file generated by the Python script
//         const data = fs.readFileSync("websites.json", "utf-8");
//         const websites = JSON.parse(data);
//         // Extract links for RSS scraping
//         return websites.map(site => site.link);
//     } catch (error) {
//         console.error("Error reading websites.json:", error);
//         return [];
//     }
// }

// async function scrapeRSSFeeds(feedUrls) {
//     console.log("Starting RSS scraping...");
//     let allArticles = [];

//     for (const url of feedUrls) {
//         try {
//             console.log(`Fetching data from: ${url}`);
//             const feed = await parser.parseURL(url);

//             // Process feed items and store them
//             const siteArticles = feed.items.map(item => ({
//                 site: feed.title,
//                 title: item.title,
//                 link: item.link,
//                 pubDate: new Date(item.pubDate),
//                 contentSnippet: item.contentSnippet || "",
//             }));

//             console.log(`Fetched ${siteArticles.length} articles from ${url}`);
//             allArticles.push(...siteArticles);
//         } catch (error) {
//             console.error(`Error fetching data from ${url}:`, error.message);
//         }
//     }

//     // Remove duplicates and sort articles
//     const uniqueArticles = allArticles.filter(
//         (article, index, self) =>
//             index === self.findIndex(a => a.link === article.link)
//     );

//     uniqueArticles.sort((a, b) => b.pubDate - a.pubDate);

//     // Save the combined articles to a JSON file
//     fs.writeFileSync("cybersecurity_news_data.json", JSON.stringify(uniqueArticles, null, 2));
//     console.log("Scraped data saved to cybersecurity_news_data.json");
// }

// function startScraping() {
//     // Load feed URLs dynamically
//     const feedUrls = loadWebsitesFromJSON();
//     if (feedUrls.length === 0) {
//         console.log("No URLs available for scraping.");
//         return;
//     }

//     scrapeRSSFeeds(feedUrls)
//         .then(() => console.log("RSS scraping completed."))
//         .catch(error => console.error("Error during RSS scraping:", error));
// }

// // Schedule the scraper to run every 5 minutes
// schedule.scheduleJob("*/3 * * * *", startScraping);

// // Initial scrape on startup
// startScraping();


// const fs = require("fs");
// const axios = require("axios");
// const cheerio = require("cheerio");
// const puppeteer = require("puppeteer");
// const RSSParser = require("rss-parser");
// const schedule = require("node-schedule");

// // Initialize RSS parser
// const parser = new RSSParser();

// // Read websites from JSON (from the previous website generation code)
// function loadWebsitesFromJSON() {
//     try {
//         const data = fs.readFileSync("websites.json", "utf-8");
//         const websites = JSON.parse(data);
//         return websites.map(site => site.link);
//     } catch (error) {
//         console.error("Error reading websites.json:", error);
//         return [];
//     }
// }

// // Static Scraping (for websites with static content)
// async function scrapeStaticWebsite(url) {
//     try {
//         const response = await axios.get(url);
//         const $ = cheerio.load(response.data);

//         // Extract structured data from static websites
//         const title = $("h1.article-title").text() || "No Title";
//         const content = $("div.article-body").text() || "No Content";
//         const pubDate = $("time").attr("datetime") || "No Date";
//         const author = $("span.author-name").text() || "No Author";

//         return {
//             url,
//             title,
//             content,
//             pubDate,
//             author,
//         };
//     } catch (error) {
//         console.error(`Error scraping static website ${url}:`, error.message);
//         return null;
//     }
// }

// // Dynamic Scraping (using Puppeteer for JS-heavy websites)
// async function scrapeDynamicWebsite(url) {
//     const browser = await puppeteer.launch();
//     const page = await browser.newPage();
//     await page.goto(url);

//     const data = await page.evaluate(() => {
//         return {
//             title: document.querySelector('h1.article-title') ? document.querySelector('h1.article-title').innerText : "No Title",
//             content: document.querySelector('div.article-body') ? document.querySelector('div.article-body').innerText : "No Content",
//             pubDate: document.querySelector('time') ? document.querySelector('time').getAttribute('datetime') : "No Date",
//         };
//     });

//     await browser.close();
//     return data;
// }

// // Scraping RSS Feeds (using RSSParser)
// async function scrapeRSSFeeds(feedUrls) {
//     console.log("Starting RSS scraping...");
//     let allArticles = [];

//     for (const url of feedUrls) {
//         try {
//             console.log(`Fetching data from: ${url}`);
//             const feed = await parser.parseURL(url);

//             // Process feed items and store them
//             const siteArticles = feed.items.map(item => ({
//                 site: feed.title,
//                 title: item.title,
//                 link: item.link,
//                 pubDate: new Date(item.pubDate),
//                 contentSnippet: item.contentSnippet || "",
//             }));

//             console.log(`Fetched ${siteArticles.length} articles from ${url}`);
//             allArticles.push(...siteArticles);
//         } catch (error) {
//             console.error(`Error fetching RSS data from ${url}:`, error.message);
//         }
//     }

//     // Remove duplicates and sort articles by date
//     const uniqueArticles = allArticles.filter(
//         (article, index, self) => index === self.findIndex(a => a.link === article.link)
//     );
//     uniqueArticles.sort((a, b) => b.pubDate - a.pubDate);

//     // Save the data to a file
//     fs.writeFileSync("cybersecurity_news_data.json", JSON.stringify(uniqueArticles, null, 2));
//     console.log("Scraped RSS data saved to cybersecurity_news_data.json");
// }

// // Combine all scraping methods
// async function scrapeAllSources() {
//     const feedUrls = loadWebsitesFromJSON();

//     if (feedUrls.length === 0) {
//         console.log("No URLs available for scraping.");
//         return;
//     }

//     // Start with scraping RSS feeds
//     await scrapeRSSFeeds(feedUrls);

//     // Scrape static websites
//     const staticWebsiteData = await scrapeStaticWebsite("https://www.ncsc.gov.uk/collection/device-security-guidance/managing-deployed-devices/logging-and-protective-monitoring");
//     console.log("Fetched static website data:", staticWebsiteData);

//     // Scrape dynamic websites using Puppeteer
//     const dynamicWebsiteData = await scrapeDynamicWebsite("https://www.security.com/threat-intelligence/budworm-tool-update-telecoms-govt");
//     console.log("Fetched dynamic website data:", dynamicWebsiteData);
// }

// // Schedule the scraper to run every 3 minutes
// schedule.scheduleJob("*/3 * * * *", scrapeAllSources);

// // Initial scrape on startup
// scrapeAllSources().catch(error => console.error("Error during scraping:", error));


// const fs = require("fs");
// const RSSParser = require("rss-parser");
// const schedule = require("node-schedule");
// const axios = require("axios");
// const cheerio = require("cheerio");
// const puppeteer = require("puppeteer");

// const parser = new RSSParser();

// function loadWebsitesFromJSON() {
//     try {
//         const data = fs.readFileSync("websites.json", "utf-8");
//         const websites = JSON.parse(data);
//         return websites.map(site => site.link);
//     } catch (error) {
//         console.error("Error reading websites.json:", error);
//         return [];
//     }
// }

// async function scrapeRSSFeeds(feedUrls) {
//     console.log("Starting RSS scraping...");
//     let allArticles = [];

//     for (const url of feedUrls) {
//         try {
//             console.log(`Fetching data from: ${url}`);
//             const feed = await parser.parseURL(url);

//             const siteArticles = feed.items.map(item => ({
//                 site: feed.title,
//                 title: item.title,
//                 link: item.link,
//                 pubDate: new Date(item.pubDate),
//                 contentSnippet: item.contentSnippet || "",
//             }));

//             console.log(`Fetched ${siteArticles.length} articles from ${url}`);
//             allArticles.push(...siteArticles);
//         } catch (error) {
//             console.error(`Error fetching RSS data from ${url}:`, error.message);
//         }
//     }

//     const uniqueArticles = allArticles.filter(
//         (article, index, self) => index === self.findIndex(a => a.link === article.link)
//     );

//     uniqueArticles.sort((a, b) => b.pubDate - a.pubDate);

//     fs.writeFileSync("cybersecurity_news_data.json", JSON.stringify(uniqueArticles, null, 2));
//     console.log("Scraped RSS data saved to cybersecurity_news_data.json");
// }

// async function scrapeStaticWebsite(url) {
//     try {
//         const response = await axios.get(url);
//         const $ = cheerio.load(response.data);

//         const title = $("h1.article-title").text() || "No Title";
//         const content = $("div.article-body").text() || "No Content";
//         const pubDate = $("time").attr("datetime") || "No Date";
//         const author = $("span.author-name").text() || "No Author";

//         return {
//             url,
//             title,
//             content,
//             pubDate,
//             author,
//         };
//     } catch (error) {
//         console.error(`Error scraping static website ${url}:`, error.message);
//         return null;
//     }
// }

// async function scrapeDynamicWebsite(url) {
//     const browser = await puppeteer.launch();
//     const page = await browser.newPage();
//     await page.goto(url);

//     const data = await page.evaluate(() => {
//         return {
//             title: document.querySelector('h1.article-title') ? document.querySelector('h1.article-title').innerText : "No Title",
//             content: document.querySelector('div.article-body') ? document.querySelector('div.article-body').innerText : "No Content",
//             pubDate: document.querySelector('time') ? document.querySelector('time').getAttribute('datetime') : "No Date",
//         };
//     });

//     await browser.close();
//     return data;
// }

// async function scrapeAllSources() {
//     const feedUrls = loadWebsitesFromJSON();

//     if (feedUrls.length === 0) {
//         console.log("No URLs available for scraping.");
//         return;
//     }

//     await scrapeRSSFeeds(feedUrls);

//     const staticWebsiteData = await scrapeStaticWebsite("https://www.ncsc.gov.uk/collection/device-security-guidance/managing-deployed-devices/logging-and-protective-monitoring");
//     console.log("Fetched static website data:", staticWebsiteData);

//     const dynamicWebsiteData = await scrapeDynamicWebsite("https://www.security.com/threat-intelligence/budworm-tool-update-telecoms-govt");
//     console.log("Fetched dynamic website data:", dynamicWebsiteData);
// }

// schedule.scheduleJob("*/30 * * * *", scrapeAllSources);

// scrapeAllSources();

const fs = require("fs");
const RSSParser = require("rss-parser");
const schedule = require("node-schedule");
const axios = require("axios");
const cheerio = require("cheerio");
const puppeteer = require("puppeteer");

const parser = new RSSParser();

function loadWebsitesFromJSON() {
    try {
        const data = fs.readFileSync("discovered_websites_.json", "utf-8");
        const websites = JSON.parse(data);
        return websites.map(site => site.link);
    } catch (error) {
        console.error("Error reading websites.json:", error);
        return [];
    }
}

async function determineScrapingMethod(url) {
    try {
        console.log(`Checking if ${url} supports RSS feed...`);
        const feed = await parser.parseURL(url);
        console.log(`RSS feed found for ${url}`);
        return { method: "rss", feed };
    } catch (rssError) {
        console.log(`No RSS feed found for ${url}, switching to web scraping...`);

        try {
            const response = await axios.get(url);
            const $ = cheerio.load(response.data);

            const title = $("h1").text();
            if (title) {
                console.log(`Static scraping possible for ${url}`);
                return { method: "static", url };
            }
        } catch (staticError) {
            console.log(`Static scraping failed for ${url}: ${staticError.message}`);
        }

        console.log(`Falling back to dynamic scraping for ${url}`);
        return { method: "dynamic", url };
    }
}

async function scrapeData(url) {
    const { method, feed } = await determineScrapingMethod(url);

    if (method === "rss") {
        const articles = feed.items.map(item => ({
            site: feed.title,
            title: item.title,
            link: item.link,
            pubDate: new Date(item.pubDate),
            contentSnippet: item.contentSnippet || "",
        }));
        console.log(`Fetched ${articles.length} articles via RSS from ${url}`);
        return articles;
    } else if (method === "static") {
        const staticData = await scrapeStaticWebsite(url);
        console.log("Fetched static website data:", staticData);
        return staticData;
    } else if (method === "dynamic") {
        const dynamicData = await scrapeDynamicWebsite(url);
        console.log("Fetched dynamic website data:", dynamicData);
        return dynamicData;
    }
}

async function scrapeRSSFeeds(feedUrls) {
    console.log("Starting RSS scraping...");
    let allArticles = [];

    for (const url of feedUrls) {
        try {
            console.log(`Fetching data from: ${url}`);
            const feed = await parser.parseURL(url);

            const siteArticles = feed.items.map(item => ({
                site: feed.title,
                title: item.title,
                link: item.link,
                pubDate: new Date(item.pubDate),
                contentSnippet: item.contentSnippet || "",
            }));

            console.log(`Fetched ${siteArticles.length} articles from ${url}`);
            allArticles.push(...siteArticles);
        } catch (error) {
            console.error(`Error fetching RSS data from ${url}:`, error.message);
        }
    }

    const uniqueArticles = allArticles.filter(
        (article, index, self) => index === self.findIndex(a => a.link === article.link)
    );

    uniqueArticles.sort((a, b) => b.pubDate - a.pubDate);

    fs.writeFileSync("cybersecurity_news_data_update.json", JSON.stringify(uniqueArticles, null, 2));
    console.log("Scraped RSS data saved to cybersecurity_news_data.json");
}

async function scrapeStaticWebsite(url) {
    try {
        const response = await axios.get(url);
        const $ = cheerio.load(response.data);

        const title = $("h1.article-title").text() || "No Title";
        const content = $("div.article-body").text() || "No Content";
        const pubDate = $("time").attr("datetime") || "No Date";
        const author = $("span.author-name").text() || "No Author";

        return {
            url,
            title,
            content,
            pubDate,
            author,
        };
    } catch (error) {
        console.error(`Error scraping static website ${url}:`, error.message);
        return null;
    }
}

async function scrapeDynamicWebsite(url) {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.goto(url);

    const data = await page.evaluate(() => {
        return {
            title: document.querySelector('h1.article-title') ? document.querySelector('h1.article-title').innerText : "No Title",
            content: document.querySelector('div.article-body') ? document.querySelector('div.article-body').innerText : "No Content",
            pubDate: document.querySelector('time') ? document.querySelector('time').getAttribute('datetime') : "No Date",
        };
    });

    await browser.close();
    return data;
}

async function scrapeAllSources() {
    const feedUrls = loadWebsitesFromJSON();

    if (feedUrls.length === 0) {
        console.log("No URLs available for scraping.");
        return;
    }

    let allData = [];
    for (const url of feedUrls) {
        const data = await scrapeData(url);
        if (Array.isArray(data)) {
            allData.push(...data);
        } else if (data) {
            allData.push(data);
        }
    }

    fs.writeFileSync("cybersecurity_news_data_updated.json", JSON.stringify(allData, null, 2));
    console.log("Scraped data saved to cybersecurity_news_data.json");
}

schedule.scheduleJob("*/3 * * * *", scrapeAllSources);

scrapeAllSources();
